PROGRAM Main
VAR

    bCAN1InByte0    AT %MB0.0   : BYTE;     (* mapped to Index=2000/Sub1 *)
    bCAN1InByte1    AT %MB1.0   : BYTE;     (* not mapped                *)
    bCAN1InByte2    AT %MB2.0   : BYTE;     (* not mapped                *)
    bCAN1InByte3    AT %MB3.0   : BYTE;     (* mapped to Index=2000/Sub1 *)
    bCAN1InByte4    AT %MB4.0   : BYTE;     (* not mapped                *)
    bCAN1InByte5    AT %MB5.0   : BYTE;     (* not mapped                *)
    bCAN1InByte6    AT %MB6.0   : BYTE;     (* mapped to Index=2000/Sub1 *)
    bCAN1InByte7    AT %MB7.0   : BYTE;     (* not mapped                *)

    bCAN1InWord0    AT %MW0.0   : WORD;     (* this overlapps 'bCAN1InByte0' and 'bCAN1InByte1' *)
    bCAN1InWord2    AT %MW2.0   : WORD;     (* this overlapps 'bCAN1InByte0' and 'bCAN1InByte1' *)
    bCAN1InWord4    AT %MW4.0   : WORD;     (* this overlapps 'bCAN1InByte0' and 'bCAN1InByte1' *)
    bCAN1InWord6    AT %MW6.0   : WORD;     (* this overlapps 'bCAN1InByte0' and 'bCAN1InByte1' *)

    bCAN1OutByte0   AT %MB256.0 : BYTE;     (* mapped to Index=2030/Sub1 *)
    bCAN1OutByte1   AT %MB257.0 : BYTE;     (* mapped to Index=2030/Sub2 *)
    bCAN1OutByte2   AT %MB258.0 : BYTE;     (* mapped to Index=2030/Sub2 *)
    bCAN1OutByte3   AT %MB259.0 : BYTE;     (* mapped to Index=2030/Sub1 *)
    bCAN1OutByte4   AT %MB260.0 : BYTE;     (* mapped to Index=2030/Sub2 *)
    bCAN1OutByte5   AT %MB261.0 : BYTE;     (* mapped to Index=2030/Sub2 *)
    bCAN1OutByte6   AT %MB262.0 : BYTE;     (* mapped to Index=2030/Sub1 *)
    bCAN1OutByte7   AT %MB263.0 : BYTE;     (* mapped to Index=2030/Sub2 *)

    wOldDataWord0                : WORD;
    wOldDataWord2                : WORD;
    wOldDataWord4                : WORD;
    wOldDataWord6                : WORD;


    udiDataCounter              : UDINT := 0;

END_VAR

(*=========================================================================*)
(*      PROGRAM Main   (used as Main Task)                                 *)
(*=========================================================================*)
(*                                                                         *)
(* This is the main task of this demo project. It only makes some very     *)
(* simple processing of a couple of network variables. This variables are  *)
(* located in the static Object Dictionary and mapped to the marker area   *)
(* of the process image                                                    *)
(*                                                                         *)
(* The important part of this demo project is the Startup Task             *)
(* 'SetupCAN1.ST'. Here the configuration of the 1st RPDO and TPDO of the  *)
(* static local Object Dictionary is done.                                 *)
(*                                                                         *)
(* NOTE: The PLC processes its network variables only in CANopen state     *)
(*       'OPERATIONAL'. Therefore it's necessary that a Master is present  *)
(*       in the network. If there is no other deticated master, configure  *)
(*       the PLC to 'CANopenMaster = ON'.                                  *)
(*                                                                         *)
(*-------------------------------------------------------------------------*)
(*      (c) SYSTEC electronic GmbH 2009     -rs                            *)
(*=========================================================================*)

IF ((wOldDataWord0 <> bCAN1InWord0) or (wOldDataWord2 <> bCAN1InWord2) 
	or (wOldDataWord4 <> bCAN1InWord4) or (wOldDataWord6 <> bCAN1InWord6)) THEN

    wOldDataWord0 := bCAN1InWord0;
    wOldDataWord2 := bCAN1InWord2;
    wOldDataWord4 := bCAN1InWord4;
    wOldDataWord6 := bCAN1InWord6;

    udiDataCounter := udiDataCounter + 1;

    bCAN1OutByte0 := bCAN1InByte0;
    bCAN1OutByte1 := bCAN1InByte1;
    bCAN1OutByte2 := bCAN1InByte2;
    bCAN1OutByte3 := bCAN1InByte3;
    bCAN1OutByte4 := bCAN1InByte4;
    bCAN1OutByte5 := bCAN1InByte5;
    bCAN1OutByte6 := bCAN1InByte6;
    bCAN1OutByte7 := bCAN1InByte7;
	
    bCAN1OutByte7 := UDINT_TO_BYTE (udiDataCounter);

END_IF;

RETURN;




END_PROGRAM